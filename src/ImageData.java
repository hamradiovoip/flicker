/* File: ImageData.java */

import java.awt.*;
import java.awt.image.*;
import java.util.*;
import java.lang.*;
import java.io.*;

/** 
 * ImageData class supports image data object access. This is the top
 * level data structure for a basic image object (left or right).  It
 * contains the input and output Image objects and input and output 
 * int[] pix arrays.
 *
 *<P>
 * This work was produced by Peter Lemkin of the National Cancer
 * Institute, an agency of the United States Government.  As a work of
 * the United States Government there is no associated copyright.  It is
 * offered as open source software under the Mozilla Public License
 * (version 1.1) subject to the limitations noted in the accompanying
 * LEGAL file. This notice must be included with the code. The Flicker 
 * Mozilla and Legal files are available on 
 * http://open2dprot.sourceforge.net/Flicker
 *<P>
 * @author P. Lemkin (LECB/NCI), G. Thornwall (SAIC), Frederick, MD
 * @version $Date$   $Revision$
 * @see <A HREF="http://open2dprot.sourceforge.net/Flicker">Flicker Home</A>
 */

public class ImageData
{ /* class ImageData */
    
  /** Flicker global classes */
  public static Flicker
    flk; 
  /** extended Flicker state variable class */
  public static Util
    util; 
  
  /** Unknown image type */
  final public int
    IMG_TYPE_UNKNOWN= 0;
  /** GIF image type */
  final public int
    IMG_TYPE_GIF= 1;
  /** JPEG image type */
  final public int
    IMG_TYPE_JPG= 2;
  /** TIFF image type */
  final public int
    IMG_TYPE_TIF= 3;
  /** GELLAB-II PPX image type */
  final public int
    IMG_TYPE_PPX= 4;
  /** [FUTURE] JPEG2000 image type. Could possibly use JJ2000 
   * at http://jj2000.epfl.ch/
   */
  final public int
    IMG_TYPE_J2K= 5;
  

  /* -- dynamic instances of data for 'this.' image -- */
  
  /* ------------------------------------------------------ */
  /*      Image data for iImg, oImg, zImg, bcImg            */
  /*      and pixel data iPix[] for this image              */
  /* ------------------------------------------------------ */
  /** input image. This is the original image and does NOT change. */
  public Image  
    iImg= null;
  /** output image generated by ImageXform. If sequential transforms
   * are used, then this will also be used for the next round of tranform
   * as the input image and then replaced with the computed output image. */
  public Image  
    oImg= null;	
   /** ZoomMag filtered image if used. */
  public Image
    zImg= null;	
   /** brightness contrast filtered image if used. */
  public Image
    bcImg= null;
  
  /** Image current object mark */
  public int
    xObj= -1;
  /** Image current object mark */
  public int
    yObj= -1;
  /** width of original input image */
  public int
    iWidth;			
  /** height of original input image */
  public int
    iHeight;			
  /** zoomed width */
  public int
    zoomedWidth;
 /** zoomed height */
  public int
    zoomedHeight;  
  
  /** image type is one of IMG_TYPE_xxx */
  public int
    imgType= IMG_TYPE_UNKNOWN;  
  
  /** Is true if it is a color image where red!=green or red!=blue or
   * when it is read in. This flag can then be tested if we want to 
   * map the (R,G,B) to NTSC(R,G,B) grayscale on a pixel level so
   * we could quantify the color data.
   */
  public boolean
    isColorImgFlag= false; 
  /** Is true if original input image has BLACK as gray value 0, 
   * else WHITE is gray value 0
   */
  public boolean
    blackIsZeroFlag= true; 
  /** # of bits/pixel. E.g., 8, 12, 16 bits */
  public int
    nBitsPerPixel= 8; 
  /** bit mask to get the pixel (1 << nBitsPerPixel) -1 */
  public int
    pixelMask= 0377; 
  /** maximum Gray value seen in the original iPix[]. -1 means
   * it is not defined.
   */
  public int
    maxG= -1;  
  /** minimum Gray value seen in the original iPix[]. -1 means
   * it is not defined.
   */
  public int
    minG= -1; 
    
  /** For ImageXform and display - input image pixel data for display.
   * Although the original image can be 8, 12, 16-bits, it is scaled in
   * the image loaders to 8-bits if it is a grayscale image. By default
   * we get the 8-bit data from the LSB or blue 8-bit channel.
   */
  public int
    iPix[]= null;
  
   /** report errors on loading else ignore messages */
  public static boolean
    reportErrorMsgsFlag;
  /** last error message associated with obj*/
  public String 
    errStr;
  /** full-path input image file name */
  public String 
    imageFile;			
  /** starting time of last transform */
  public long
    startTime;		
  /** ending time of last transform */
  public long
    endTime;		
  /** # of milli-seconds to process last transform*/
  public int
    runTimeMsec;
    
  /** User enabled image as clickable DB checkbox to get DB entry */
  public boolean
    userClickableImageDBflag;  
  /** flag set if currently selected image is clickable */
  public boolean 
    isClickableDBflag;
  
  /** Index Color map */
  private IndexColorModel
    icm;		
  /** set by doXform, cleared by doneWithXform */
  boolean
    doingTransform= false;
  /** Ok to paint ImageScroller */
  boolean
    threadIsPaintFlag= true;
  /** current title for image scroller associated with iData */
  public String	  	 
    title;	
    /** zoom value */
  int
    zoomMagScr;
  /** magnification factor */
  double
    mag;
  /** */
  float
    magVal;
  /* ---------------------------------------------------- */
  /*                SliderState data                      */
  /* ---------------------------------------------------- */
  /** SliderState threshold parameters associated with the image */
  public SliderState 
    state;
  
  /* ---------------------------------------------------- */
  /*                Spot boundary data  [FUTURE]          */
  /* ---------------------------------------------------- */
  /** This boundary boundary is ImageData specific. */
  public Boundary
    bnd;  
    
  /* ---------------------------------------------------- */
  /*                Calibration data                      */
  /* ---------------------------------------------------- */
  /** calibration data is ImageData specific */
  public CalibrateOD
    calib;		
  /** mapGrayToOD data if not null */
  public float
    mapGrayToOD[];  
  /** Indicates that there is an valid mapGrayToOD map
   * else if it was set to 1:1 the flag is set false.
   */
  public boolean
    hasODmapFlag;
  
  /** Histogram of data [0:maxGray] */
  public int
    hist[];
  
  /** generic ROI popup histogram for image */ 
  public DrawHistogram
    dwHist= null;  
  /** generic Calibration popup histogram for image */ 
  public DrawHistogram
    dwCalHist= null;
  
      
  /** Spot list (measured spots) for this image */
  public ImageDataSpotList
    idSL;
     
  /** Current measured circular mask spot for this image */  
  public ImageDataMeas
    idM;  
  
  /** Region(s) Of Interest (ROI).
   * Note that the ND step wedge ROI is kept in and maintained by
   * calib.{ndcwx1,ndcwx2,ndcwy1,ndcwy2}
   */
  public ImageDataROI
    idROI;
  
  
  /**
   * ImageData() - Constructor. Obj keeps all image data together.
   * Assumption: image, widthA, heightA and iPixA must exist before
   * the class instance is created.
   * Note: newImg must exist completely in memory at this point.
   * Setup up a 1:1 mapGrayToOD[0:maxGray] if mapGrayToOD is null.
   * @param iName is name of image
   * @param newImg is existing input image to setthis.iImg.
   * @param iSize is size of image
   * @param blackIsZeroFlag is true if image has black as 0 gray value
   * @param mapGrayToOD is Map of Gray to OD if exists
   * @param flk is instance of Flicker
   */
  public ImageData(String iName, Image newImg, Dimension iSize,
                   boolean blackIsZeroFlag, float mapGrayToOD[], 
                   Flicker flkS)
  { /* ImageData */
    this.imageFile= iName;
    flk= flkS;                           /* static */
    util= flk.util;
    
    /* Make instances of ImageData extensions */
    idROI= new ImageDataROI(this);    
    idSL= new ImageDataSpotList(this);
    idM= new ImageDataMeas(this);
    
    /* Setup database for slider state */
    state= new SliderState();
    state.init(flk,iName);
    //state.delay= def_delay;
        
    changeImageData(iName, newImg, iSize, blackIsZeroFlag, mapGrayToOD); 
    
    idM.setupCircularMaskStatistics();  /* set the radius to flk.nCirMask */
  } /* ImageData */
  
  
  /**
   * ImageData() - Constructor for extensions
   */
  public ImageData()
  { /* ImageData */
  } /* ImageData */
  
  
  /**
   * getImgType() - get image type from IMG_TYPE_xxx
   * @return image type
   */
  public int getImgType()
  { return(imgType); }
  
  
  /**
   * setTitle() - change the title for the ImageData instance.
   * You can do a temporary change or a permanent change.
   * @param title to use
   */
  public void setTitle(String title)
  { this.title= title; }


  /**
   * setDefaultGrayscaleIndexColorMap() - set the RGB IndexColorMap from 
   * (r,g,b) maps
   * Note: see Hacking Java, pg 90 on cycling color palette
   * [TODO] Update the display...
   * @param r is red map
   * @param g is green map
   * @param b is blue map
   */
  public void setDefaultGrayscaleIndexColorMap(byte r[], byte g[], byte b[])
  { this.icm= new IndexColorModel(8,256,r,g,b); }
  
  
  
  /* ------------------------------------------------------ */
  /*      Image data for iImg, oImg, zImg, bcImg            */
  /*      and pixel data iPix[] for this image              */
  /* ------------------------------------------------------ */
  
  /**
   * setDefaultGrayscaleIndexColorMap() - set the default grayscale colormap
   * to a RGB IndexColorMap with all colors the same
   */
  public void setDefaultGrayscaleIndexColorMap()
  { /* setDefaultGrayscaleIndexColorMap */
    byte red[]= new byte[256];
    byte green[]= new byte[256];
    byte blue[]= new byte[256];
    for(int i=0; i<256; i++)
    {
      byte b;
      if(i<128)
        b= (byte)i;
      else
        b= (byte)(-255 + (i-128)/128);
      red[i]= b;
      green[i]= b;
      blue[i]= b;
    }
    
    /* Create colormap */
    this.setDefaultGrayscaleIndexColorMap(red,green,blue); 
  } /* setDefaultGrayscaleIndexColorMap */
       
  
  /**
   * resetImageData() - reset this ImageData object.
   * It does not change the name of the file, black is white flag
   * nor mapGrayToOD.
   * @param iImgFlushFlag to flush iImg if true
   */
  public synchronized void resetImageData(boolean iImgFlushFlag)
  { /* resetImageData */                            
    /* [1] Release old images and 'stuff' and then garbage collect memory 
     * before create additional data.
     * See Chen&Lee Vol 2, pg 801-802 for freeing resources.
     */   
    if(iImgFlushFlag)
    {
      ImageIO.flushImageResources(iImg);
      iImg= null;
    }
    
    ImageIO.flushImageResources(oImg);
    oImg= null;		                /* will remake it if and when need i */
    
    ImageIO.flushImageResources(zImg);
    zImg= null;		                /* will remake it if and when need i */
    
    ImageIO.flushImageResources(bcImg);
    bcImg= null;                  /* will remake it if and when need i */
    
    if(bnd!=null)
      bnd.clean();
    
    /* [2] Reinitialize the landmarks data structures */
    flk.lms.clean();              /* clears all landmarks */ 
    
    /* Clear idSL.spotList[0:nSpots-1].
     * Prompt "are you sure" and clear spot list if 'yes'.
     * Clean up spotlist and backup spot list.
     */
    idSL.clean();
    
    bnd= null;	  	              /* will make it if and when need it */ 
    iPix= null;		                /* input image pixel data */
    flk.util.gcAndMemoryStats("Cleaned up old ImageData state"); 
    
    /* [2.1] Clear landmarks in the Image Scroller */
    if(this==flk.iData1)
      flk.i1IS.clearLandmarkTextListToDraw();
    else if(this==flk.iData2)
      flk.i2IS.clearLandmarkTextListToDraw();
         
    /* [3] Reset other image dependent resources */
    /* Init the image data measurement state */    
    idM.clean();
    xObj= -1;
    yObj= -1;
    errStr= "";		          /* nothing */
    
    /* Set the image type */
    if(imageFile!=null)
    { /* set file type */
      String nameLC= imageFile.toLowerCase();
      if(nameLC.endsWith(".gif"))
        imgType= IMG_TYPE_GIF;
      else if(nameLC.endsWith(".jpg"))
        imgType= IMG_TYPE_JPG;
      else if(nameLC.endsWith(".tif") || nameLC.endsWith(".tiff"))
        imgType= IMG_TYPE_TIF;
      else if(nameLC.endsWith(".ppx"))
        imgType= IMG_TYPE_PPX;
      else if(nameLC.endsWith(".j2k"))
        imgType= IMG_TYPE_J2K;
      else
        imgType= IMG_TYPE_UNKNOWN;
    } /* setfile type */
    
    /* Disable the ROI */
    idROI.setROI(-1, -1, -1, -1);              /* disable C-U/C-L ROI */
    idROI.copyROI2CW();      /* copy C-U/C-L ROI to Computing Window (CW) */
    doingTransform= false;
    
    /* Create calibration object in case we need it */
    /* [CHECK] if we really want to do a total re-calibration! */
    //if(calib!=null)
    //  calib.clean();    
    //calib= new CalibrateOD(flk, (int)maxGrayValue);    
    //calib.setMapGrayToOD(mapGrayToOD,(int)maxGrayValue); 
    //mapGrayToOD= calib.getMapGrayToOD(); 
    //hasODmapFlag= calib.getHasODmapFlag();
    
    /* Create boundary object in case want to draw boundary */
    bnd= new Boundary(flk);     
    
    /* Create list of measurement spots idSL.spotList[0:nSpots-1] */
    idSL.clean();   
  } /* resetImageData */

  
  /**
   * changeImageData() - change values of this ImageData object
   * @param iName is name of image
   * @param newImg is existing input image to set to this ImageData instance
   * @param iSize is size of image
   * @param blackIsZeroFlag is true if image has black as 0 gray value
   * @param mapGrayToOD is Map of Gray to OD if exists and is not null
   */
  public synchronized void changeImageData(String iName, Image newImg,
                                           Dimension iSize,  
                                           boolean blackIsZeroFlag,
                                           float mapGrayToOD[])
  { /* changeImageData */    
    /* [1] Release old images and 'stuff' and then garbage collect memory 
     * before create additional data.
     * See Chen&Lee Vol 2, pg 801-802 for freeing resources.
     */     
   ImageIO.flushImageResources(iImg);
    iImg= null;
    
    ImageIO.flushImageResources(oImg);
    oImg= null;		            /* will remake it if and when need it */
    
    ImageIO.flushImageResources(bcImg);
    bcImg= null;                   /* will remake it if and when need it */
    
    /* [1.1] Clean up old calibration and boundary objects */
    if(calib!=null)
      calib.clean();
    if(bnd!=null)
      bnd.clean();
    
    /* [1.2] reinitialize the landmarks data structures */
    flk.lms.clean(); 
    
    /* [1.3] Clear the spot measurment list - offer to save first. */  
     if(idSL.changeSpotList)
       idSL.clean();                  /* prompt first if need to ask if save list */
     else
       idSL.forceClearSpotList(); 
    
    calib= null;	              /* will make it if and when need it */ 
    bnd= null;	  	              /* will make it if and when need it */ 
    iPix= null;		              /* input image pixel data */
    flk.util.gcAndMemoryStats("Cleaned up old ImageData state"); 
     
    /* [2] Copy new params */
    imageFile= iName;
    iImg= newImg;		       /* input image */
    iWidth= iSize.width;
    iHeight= iSize.height;
    
    /* User enabled image as clickable DB checkbox to get DB entry */
    userClickableImageDBflag= false;  
    /* flag set if currently selected image is clickable */
    isClickableDBflag= false;
  
    /* [3] Reset other image dependent resources */
    /* Init the image data measurement state */    
    idM.clean();
    xObj= -1;
    yObj= -1;    
    errStr= "";		                 /* nothing */
    /* Set the image type */
    String nameLC= iName.toLowerCase();
    if(nameLC.endsWith(".gif"))
      imgType= IMG_TYPE_GIF;
    else if(nameLC.endsWith(".jpg"))
      imgType= IMG_TYPE_JPG;
    else if(nameLC.endsWith(".tif") || nameLC.endsWith(".tiff"))
      imgType= IMG_TYPE_TIF;
    else if(nameLC.endsWith(".ppx"))
      imgType= IMG_TYPE_PPX;
    else if(nameLC.endsWith(".j2k"))
      imgType= IMG_TYPE_J2K;
    else
      imgType= IMG_TYPE_UNKNOWN;
    /* disable the ROI */
    idROI.setROI(-1, -1, -1, -1);              /* disable C-U/C-L ROI */
    idROI.copyROI2CW();      /* copy C-U/C-L ROI to Computing Window (CW) */
    doingTransform= false;
    
    /* [4] Create calibration object in case we need it */
    calib= new CalibrateOD(flk, (int)idM.maxGrayValue);  
    /* Change the mapGrayToOD to the specified Gray to OD map.  
     * However, if the map does not exist then make a 256 level
     * 1:1 map.
     */
    calib.setMapGrayToOD(mapGrayToOD, (int)idM.maxGrayValue); 
    /* Now, copy the map to this LOCAL state of ImageData where we 
     * will use the local copy for all pixel computations.
     */
    this.mapGrayToOD= calib.getMapGrayToOD();
    hasODmapFlag= calib.getHasODmapFlag(); 
    
    /* [5] Create boundary object in case want to draw boundary */
    bnd= new Boundary(flk);    
  } /* changeImageData */
   
  
  /**
   * resizeImageToTargetSize() - resize image to target size if the
   * w or h is outside the range [minTargetSize : maxTargetSize].
   * We resize if we DO need to resize AND (targetSize!=0).
   * Also keep the (h/w) aspect ratio the same.
   * @param img is image to resize
   * @param w is actual width
   * @param h is actual height
   * @param minTargetSize allowed 
   * @param maxTargetSize allowed
   * @param targetSize to set the image to if resizing and it is not 0
   * @return new image if had to resize it, else return the old image
   */
  public static Image resizeImageToTargetSize(Image img, int w, int h, 
                                              int minTargetSize,
                                              int maxTargetSize, 
                                              int targetSize)
  { /* resizeImageToTargetSize */
    Image rImg= img;  /* The default is original image if no resizing */
    
    /* [TODO] test this code */
    if(targetSize!=0 && /* do NOT allow resizing if this is 0 !!!! */
       (w<minTargetSize || h<minTargetSize ||
        w>maxTargetSize || h>maxTargetSize))
    { /* resize it proportionately */
      int
        h1= h,
        w1= w;
      float
        f,
        fH= (float)targetSize/(float)h1,
        fW= (float)targetSize/(float)w1;
      
      if(fH>1.0 && fW>1.0)
        f= Math.max(fH,fW);
      else if(fH<1.0 && fW<1.0)
        f= Math.min(fH,fW);
      else if(fH<1.0 && fW>1.0)
        f= (fH>1.0/fW) ? fH : fW;
      else f= (fW>1.0/fW) ? fW : fH;
      
      float fI= (float)1.0/f;
      int
        x2, y2,
        h2= (int)(f*h1),
        w2= (int)(f*w1);
      int
        inPix[]= getPixelDataFromImage(img,w1,h1),
        outPix[]= new int[h2*w2];
      
      for(y2=0; y2<h2; y2++)
      { /* sample and copy pixels from old to new image */
        int
          y1= (int)(fI*y2),
          y1w1= y1*w1,
          y2w2= y2*w2;
        
        for(x2= 0; x2<w2; x2++)
        {
          int
            x1= (int)(fI*x2),
            g= inPix[y1w1 + x1];	/* sample it */
          
          outPix[y2w2 + x2]= g;
        }
      } /* sample and copy pixels from old to new image */
      
      /* replace it */
      inPix= null;		              /*  first force G.C. */
      util.gcAndMemoryStats("Cleanup inPix ImageData before resize");
      
      Toolkit dtk= Toolkit.getDefaultToolkit();
      MemoryImageSource mis= new MemoryImageSource(w2,h2, outPix, 0, w2);
      
      rImg= dtk.createImage(mis);   
      
      outPix= null;		              /*  Then force G.C. */
      dtk= null;
      mis= null;
      util.gcAndMemoryStats("Cleanup outPix ImageData after resize");         
    } /* resize it proportionately */
    
    return(rImg);
  } /* resizeImageToTargetSize */
  
  
  /**
   * getPixelDataFromImage() - get the pixel data from the image
   * @param img image to use
   * @param width of image
   * @param height of image
   * @return int[] array of pixel data,
   */
  private static int[] getPixelDataFromImage(Image img, int width, int height)
  { /* getPixelDataFromImage */
    int
      i,
      size= width*height,
      inPix[]= new int[size];              /* will G.C. when return */
    
    PixelGrabber grabber= new PixelGrabber(img, 0, 0, width, height,
                                           inPix, 0, width );
    boolean done= false;
    do
    { /* grab pixels for 500 msec */
      try
      {
        done= grabber.grabPixels( 500 );
      }
      catch ( InterruptedException e )
      {
        /* util.showMsg( "Image IO interrupted.", Color.red); */
        grabber= null;
        util.gcAndMemoryStats("getPixelDataFromImage():Image IO interrupted.");  
        return(null);
      }
    }
    while( !done );
    
    if((grabber.status() & ImageObserver.ABORT) != 0)
    {
       grabber= null;
       util.gcAndMemoryStats("getPixelDataFromImage():Cleanup after PixelGrabber");  
       return(null);
    }
    
    grabber= null;
    util.gcAndMemoryStats("getPixelDataFromImage():Cleanup after PixelGrabber");  
    return(inPix);
  } /* getPixelDataFromImage */
  
  
  /**
   * loadBlankImageData() - create and return a blank ImageData object
   * [NOTE] This code has a bug since it does not create the empty
   * window correctly. It could be called initially from 
   * flk.initialImageLoad() if the call to load an initial image 
   * using loadPixIntoImageData() fails.
   * @param name of empty image to create
   * @param w is width of empty image 
   * @param h is height of empty image
   * @return ImageData instance
   */
  public ImageData loadBlankImageData(String name, int w, int h)
  { /* loadBlankImageData */
    this.imageFile= name;
    int size= w*h;
    int tmpPix[]= new int[size];
    for(int i=0;i<size;i++)
      tmpPix[i]= -1;  /* while image has (alpha,r,g,b) all 255) */
    Toolkit dtk= Toolkit.getDefaultToolkit();
    MemoryImageSource mis= new MemoryImageSource(w,h,tmpPix,0,w);
    Image rImg= dtk.createImage(mis);
    tmpPix= null;		                         /*  Then force G.C. */
    mis= null;
    util.gcAndMemoryStats("Cleanup tmpPix ImageData["+name+
                           "] after loadBlankImageData"); 
    
    Dimension iSize= new Dimension(w,h);
    ImageData iData= new ImageData(name, rImg, iSize,
                                   true, /* blackIsZeroFlag */
                                   null, /* no mapGraytoOD[] */
                                   flk); 
    return(iData);
  } /* loadBlankImageData */
  
  
  /**
   * checkAndMakeIpix() - check & make iData.iPix if !exists.
   * This gets the generic iImg or oImg data.
   * @param reportErrorMsgsFlag to report error it it occurs on load
   * @return false if an error.
   */
  public boolean checkAndMakeIpix(boolean reportErrorMsgsFlag)
  { return(checkAndMakeIpix("--generic--", reportErrorMsgsFlag)); }
  
  
  /**
   * checkAndMakeIpix() - check & make iData.iPix if it does not exist.
   * If we are zooming, it gets the zoom input else the image Xform image
   * which could be either iImg or oImg (if the latter exists and the 
   * switches are set according to the getImageForXformInput() rules.
   * @param useXform to check for "DeZoom" transform.
   * @param reportErrorMsgsFlag to report error it it occurs on load
   * @return false if an error.
   */
  public boolean checkAndMakeIpix(String useXform,
                                  boolean reportErrorMsgsFlag)
  { /* checkAndMakeIpix */      
    /* [1] Build iPix if needed */
    try
    { /* try to allocate and populate iPix */
      boolean forZoomFlag= (useXform.equals("DeZoom"));
      Image useImage= (forZoomFlag)
                         ? getImageForZoomInput()
                         : getImageForXformInput();
        
      /* Create input pixel array from either original image or
       * previously transformed image. MUST do each time since it 
       * could change.
       */
      if(iPix==null || flk.allowXformFlag || forZoomFlag)
      { /* convert it first time */
        /* [CHECK] this should set blackIsZeroFlag... */
        iPix= null;
        flk.util.gcAndMemoryStats("checkAndMakeIpix(): before new iPix");         
        iPix= getPixelDataFromImage(useImage, iWidth, iHeight);   
        flk.util.gcAndMemoryStats("checkAndMakeIpix(): after new iPix");   
      }
    } /* try to allocate and populate iPix */   
    catch (Exception e1)
    { /* trouble */
      iPix= null;
      flk.util.gcAndMemoryStats("checkAndMakeIpix(): Error with iPix");         
    }  
    
    if(iPix==null)
    {
      String msg= "Out of memory allocating iPix for ["+imageFile+"]";
      if(reportErrorMsgsFlag)
        util.popupAlertMsg(msg, flk.alertColor);
      flk.util.gcAndMemoryStats("Out of memory allocating iPix"); 
      return(false);
    }
    
    /* [2] Get the default #bits and pixel mask */
    nBitsPerPixel= (nBitsPerPixel==0) ? 8 : nBitsPerPixel;
    pixelMask= (1<<nBitsPerPixel)-1;
    
    /* [4] Test if image is true-color image */
    //isColorImgFlag= isRGBcolorImage();
    //if(flk.CONSOLE_FLAG)
    //   System.out.println("ID-CAMI isColorImgFlag="+isColorImgFlag);
        
    /* [3] We can optionally convert RGT to grayscale for the iPix[] data.
     * If the iPix[] data is color RGB, then apply the NTSC rgb to
     * grayscale  transform to the iPix[] data.
     *
     * First we recompute the isColorImgFlag status. If it is true,
     * it is a color image where red!=green or red!=blue.
     * This flag is then be tested if we want to map the (R,G,B) to
     * NTSC(R,G,B) grayscale on a pixel level so we could quantify
     * the color data.
     *
     * This is only applied if the flk.useNTSCrgbTograyCvtFlag and
     * the iData.isColorImgFlag was recomputed as true.
     * It always computes (minG, maxG) for the iPix[] LSB 8-bit
     * data (AFTER the NTSC conversion if required).
     */
    flk.util.gcAndMemoryStats("checkAndMakeIpix():before applyNTSCrgb2grayTransform()");   
    applyNTSCrgb2grayTransform();     
    
    util.gcAndMemoryStats("checkAndMakeIpix() Cleanup get iPix ImageData after checkAndMakeIpix");   
    return(true);
  } /* checkAndMakeIpix */  
  
  
  /**
   * isRGBcolorImage() - test if red!=green!=blue for any pixels
   * @return true if RGB color pixels. 
   */
  public boolean isRGBcolorImage()
  { /* isRGBcolorImage */
    int
      nPixels= (iWidth*iHeight),
      g,
      blue,
      green,
      red;
    boolean flag= false;
    for(int i=0;i<nPixels;i++)
    {
      g= iPix[i];
      blue= (g & 0Xff);
      green= (g & 0Xff00);
      red=  (g & 0Xff0000);
      if(red!=green || green!=blue)
      {
        flag= true;
        break;
      }
    }
    
    return(flag);
  } /* isRGBcolorImage */
    
  
  /**
   * cvtRGBvalToNTSCgrayVal() - convert RGB value to NTSC grayscale value.
   * The NTSC standard to convert RGB to Grayscale is
   * grayscale = 0.33Red + 0.5Green + 0.17Blue.
   * @param rgbPixelVal 
   */
  final public static int cvtRGBvalToNTSCgrayVal(int rgbPixelVal)
  { /* cvtRGBvalToNTSCgrayVal */
    /* Convert RGB pixel to grayscale 8-bit pixel */
    int
      red= ((rgbPixelVal >> 16) & 0xff),
      green= ((rgbPixelVal >> 8) & 0xff),
      blue= (rgbPixelVal & 0xff);
      
    /* cvt RGB to Grayscale:  0.33R + 0.50G + 0.17B */
    int g= ((red*33 + green*50 + blue*17)/100);
          
    return(g);
  } /* cvtRGBvalToNTSCgrayVal */ 
  
  
  /** 
   * applyNTSCrgb2grayTransform() - optionally convert RGT to 
   * grayscale for the iPix[] data. If the iPix[] data is color RGB,
   * then apply the NTSC rgb to grayscale  transform to the iPix[] data. 
   *<P>
   * First we recompute the isColorImgFlag status. If it is true, 
   * it is a color image where red!=green or red!=blue. 
   * This flag is then be tested if we want to map the (R,G,B) to 
   * NTSC(R,G,B) grayscale on a pixel level so we could quantify
   * the color data.
   *<P>
   * This is only applied if the flk.useNTSCrgbTograyCvtFlag and 
   * the iData.isColorImgFlag was recomputed as true. 
   * It always computes (minG, maxG) for the iPix[] LSB 8-bit
   * data (AFTER the NTSC conversion if required).
   * @return true if did conversion, else false 
   */
  public boolean applyNTSCrgb2grayTransform()
  { /* applyNTSCrgb2grayTransform */
    /* Recompute the isColorImgFlag status. If it is true, it is a color
     * image where red!=green or red!=blue. 
     * This flag is then be tested if we want to
     * map the (R,G,B) to NTSC(R,G,B) grayscale on a pixel level so
     * we could quantify the color data.
     */
    isColorImgFlag= false; 
    int 
      g,
      iSize= iWidth*iHeight,
      red, green, blue,
      gI;
    for(int k= (iSize-1);k>=0;k--)
    { /* determine if RGB color image */
      gI= iPix[k];
      red= ((gI >>16) & pixelMask);
      green= ((gI >>8) & pixelMask);
      blue= (gI & pixelMask);
      if(red!=green || red!=blue)
        isColorImgFlag= true; 
    }
      
    /* only use iPix - get the (maxG,minG) from iPix[] data */
    maxG= 0;
    minG= pixelMask;for(int k= (iSize-1);k>=0;k--)
    { /* get 8-bit data from RGB pix */
      gI= iPix[k];       
      if(isColorImgFlag && flk.useNTSCrgbTograyCvtFlag)
      { /* Convert it from RGB to grayscale */
        g= cvtRGBvalToNTSCgrayVal(gI);
        /* reset the iPix[] array */
        gI= ((g>>16) + (g>>8)+g);
        iPix[k]= gI;
      }
      else
        g= (gI & pixelMask); /* Get grayscale as lower 8-bits - i.e. blue */
      
      if((!blackIsZeroFlag))
        g= (pixelMask - g);
      
      /* Test max and min AFTER blackIsZero test */
      if(maxG<g)
        maxG= g;
      if(minG>g)
        minG= g;     
    }
    
    boolean flag= (isColorImgFlag && flk.useNTSCrgbTograyCvtFlag);
    
    return(flag);
  } /* applyNTSCrgb2grayTransform */
  
  
  /**
   * getImageForXformInput() - get the image for input to image transform.
   * If are not allowing image transforms (i.e. !flk.allowXformFlag), then
   * use the iImg. Otherwise, if we are composing output images 
   * (flk.composeXformFlag and oImg exists) then use oImg else iImg.
   * @return the Image to use, else null if error
   */
  public Image getImageForXformInput()
  { /* getImageForXformInput */
    Image img= (!flk.allowXformFlag)
                  ? this.iImg
                  : ((flk.composeXformFlag)
                        ? ((this.oImg==null)
                             ? this.iImg 
                             : this.oImg)
                        : this.iImg);
    return(img);
  } /* getImageForXformInput */    
    
    
  /**
   * getImageForZoomInput() - get image for input to ZoomMag filter.
   * If allowing image transforms (i.e. flk.allowXformFlag) and oImg exists,
   * then use oImg, else use iImg. Note: we do not care whether the oImg
   * was composed or not - just whether it exists!
   * @return the Image to use, else null if error
   */
  public Image getImageForZoomInput()
  { /* getImageForZoomInput */
    Image img= (flk.allowXformFlag && this.oImg!=null)
                  ? this.oImg
                  : this.iImg;
    
    return(img);
  } /* getImageForZoomInput */    
    
    
  /**
   * getImageForBCInput() - get image for input to Brightness/Contrast
   * filter. If zImg exists, then use that. Else if we are allowing image
   * transforms (i.e. flk.allowXformFlag) and oImg exists, then use oImg, 
   * else use iImg. 
   * Note: if change flk.allowXformFlag status, MUST resync zImg if
   * zoomMagVal is not 1.0X since different data source.
   * @return the Image to use, else null if error
   */
  public Image getImageForBCInput()
  { /* getImageForBCInput */
    Image img= (zImg!=null)
                 ? this.zImg
                 : getImageForZoomInput();
    
    return(img);
  } /* getImageForBCInput */   
    
    
  /**
   * getImageForDisplayInput() - get image for input to display painting.
   * If bcImg exists, then use it. Else if zImg exists, then use that. 
   * Else if we are allowing image transforms (i.e. flk.allowXformFlag) 
   * and oImg exists, then use oImg, else use iImg. 
   * @return the Image to use, else null if error
   */
  public Image getImageForDisplayInput()
  { /* getImageForDisplayInput */
    Image img= (this.bcImg!=null)
                 ? this.bcImg
                 : ((zImg!=null)
                      ? this.zImg
                      : ((flk.allowXformFlag && this.oImg!=null)
                           ? this.oImg
                           : this.iImg));
                           
    return(img);
  } /* getImageForDisplayInput */   
  
  
  /**
   * printImgDebugState() - Debugging print (iImg,oImg,zImg) object 
   * Java pointers. This is useful for debugging transforms etc.
   * @param msg - to print if any
   */
  public void printImgDebugState(String msg)
  { /* printImgDebugState */
    if(msg==null)
      msg= "";
    System.out.println(msg+
                       "\n   iImg="+iImg+
                       "\n   oImg="+oImg+
                       "   zImg="+zImg);      
  } /* printImgDebugState */
      
    
  /**
   * setOrigInputPixels() - set the original image iPix[] pixels
   * and associated flags. 
   * @param origInputPixels is the original pixels array data
   * @param nBitsPerPixel is # bits/pixel in the original pixels
   * @param blackIsZeroFlag is true if original input image 
   *        has BLACK as gray value 0, else WHITE is gray value 0
   * @return 
   */
  final public void setOrigInputPixels(int origInputPixels[],
                                int nBitsPerPixel,
                                boolean blackIsZeroFlag)
  { /* setOrigInputPixels */ 
    //this.nBitsPerPixel= (nBitsPerPixel==0) ? 8 : nBitsPerPixel;
    
    /* use 8-bit iPix data model */
    this.iPix= null;
    flk.util.gcAndMemoryStats("new iPix from origInputPixels"); 
    this.iPix= origInputPixels;
    this.nBitsPerPixel= 8;
    
    this.blackIsZeroFlag= blackIsZeroFlag;
    
    pixelMask= (1 << this.nBitsPerPixel)-1;
  } /* setOrigInputPixels */
  
 
  
  /**
   * printProperties() - Debugging print (iImg,oImg,zImg) object 
   * Java pointers, and  img width & height. This is useful for 
   * debugging transforms etc.
   * @param msg - to print if any
   * @param img - to print if any
   * @param zoomInputImg - to print if any
   */
  public void printProperties(String msg, Image img,
                              Image zoomInputImg)
  { /* printProperties */
    if(msg==null)
      msg= "";
    if(img==null)
      return;
    String
    oMsg= "";
    
    if(oImg!=null)
      oMsg=  " w="+iImg.getWidth(flk)+ " h="+iImg.getHeight(flk);
    
   String s= msg+ "\n  file="+imageFile+
                       "\n  iImg="+iImg+
                       " w="+iImg.getWidth(flk)+
                       " h="+iImg.getHeight(flk)+
                       "\n  oImg="+oImg+ oMsg+
                       "\n  zImg="+zImg+
                       "\n  img="+img+
                       " w="+img.getWidth(flk)+
                       " h="+img.getHeight(flk);
   if(zoomInputImg!=null)
       s += "\n imgToZoom="+zoomInputImg+
            " w="+zoomInputImg.getWidth(flk)+
            " h="+zoomInputImg.getHeight(flk);
   s += "\n  i1IS.siCanvasWH=("+flk.i1IS.siCanvas.sicWidth+"x"+
                          flk.i1IS.siCanvas.sicHeight+")";
   s += "  i2IS.siCanvasWH=("+flk.i2IS.siCanvas.sicWidth+"x"+
                          flk.i2IS.siCanvas.sicHeight+")";
   
   if(flk.NEVER)
   System.out.println(s);      
  } /* printProperties */
        
   
  /** 
   * mapStateToZoom() - map state point to zoomed/dezoomed point 
   * based on zoomMagVal.
   * This can be used for remapping overlays. 
   * @param mappedXYobj to use if not null, else create one.
   * @return zoomed point
   */
  public Point mapStateToZoom(Point XYobjToMap)
  { /* mapStateToZoom */
    if(XYobjToMap==null)
      return(null);
    int     
      newX= XYobjToMap.x,/* in case is is 1.0 */
      newY= XYobjToMap.y;       
    
    double mag= Math.max(magVal, SliderState.MIN_ZOOM_MAG_VAL);
    mag= Math.min(mag, SliderState.MAX_ZOOM_MAG_VAL);    
   
    if(mag != 1.0) 
    {
      double xDb= XYobjToMap.x * mag;
      double yDb= XYobjToMap.y * mag;    
      
      newX= (int) Math.round(xDb);
      newY= (int) Math.round(yDb);   
    } 
    
    if(flk.NEVER)
      System.out.println("ID:mapStateToZoom()x= "+XYobjToMap.x+
                         " y="+XYobjToMap.y+" newX="+newX+" newY="+newY);
    
    return(new Point(newX,newY));
  } /* mapStateToZoom */
     
    
  /** 
   * mapZoomToState() - map zoom point to state point with Guard Region
   * factored in. This can be used for remapping overlays. 
   * @param mappedXYobj to use if not null, else create one.
   * @param gw guard width
   * @param gh guard height
   * @return zoomed point, -1 if out of bounds
   */
  public Point mapZoomToState(Point zoomedXYobjToMap, int gw,
                              int gh)
  { /* mapZoomToState */
    if(zoomedXYobjToMap==null)
      return(null);
    
    double mag= Math.max(magVal, SliderState.MIN_ZOOM_MAG_VAL); 
    mag= Math.min(mag, SliderState.MAX_ZOOM_MAG_VAL);   
   
    int 
      newX= zoomedXYobjToMap.x,  /* local copy */
      newY= zoomedXYobjToMap.y;      
    
    /* adjust for guard region */
    if(flk.useGuardRegionImageFlag)
      {
        if(gw <= newX)          
          newX= newX - gw;
        else
          newX= gw - newX;
        
        if(gh <= newY)
          newY= newY - gh;     
        else
          newY= gh - newY;
      }     
    
    if(mag != 1.0)
    {/* zoomed */
      double xDb= newX/mag;
      double yDb= newY/mag;
      
      newX= (int) Math.round(xDb);
      newY= (int) Math.round(yDb);     
     
    } /* zoomed */  
     
    return(new Point(newX,newY));
  } /* mapZoomToState */
    
  /** 
   * mapZoomToState() - map zoom point to state point 
   * based on zoomMagVal.
   * This can be used for remapping overlays. 
   * @param mappedXYobj to use if not null, else create one.
   * @return zoomed point, -1 if out of bounds
   */
  public Point mapZoomToState(Point zoomedXYobjToMap)
  { /* mapZoomToState */
    if(zoomedXYobjToMap==null)
      return(null);
    
    double mag= Math.max(magVal, SliderState.MIN_ZOOM_MAG_VAL); 
    mag= Math.min(mag, SliderState.MAX_ZOOM_MAG_VAL);   
   
    int 
      newX= zoomedXYobjToMap.x,  /* local copy */
      newY= zoomedXYobjToMap.y;  
    
   if(mag != 1.0) 
    {
      double xDb= zoomedXYobjToMap.x/mag;
      double yDb= zoomedXYobjToMap.y/mag;    
      
      newX= (int) Math.round(xDb);
      newY= (int) Math.round(yDb);   
   }
    
    return(new Point(newX,newY));
  } /* mapZoomToState */
  
  
} /* class ImageData */
